# Creates folder and CD's into it
mcd() {
  mkdir -p "$1" && cd "$1";
}

# Run `dig` and display the most useful info
dug() {
  dig +nocmd "$1" any +multiline +noall +answer;
}

# Creates Backup
backup() {
  for file in "$@"; do
    local new=${file}.$(date '+%Y%m%d')
    while [[ -f $new ]]; do
      new+="~";
    done;
    printf "copying '%s' to '%s'\n" "$file" "$new";
    \cp -ip "$file" "$new";
  done
}

# Colorized cat output
dog(){
  cat "$@" > /tmp/.tmp
  pygmentize -g /tmp/.tmp
  rm /tmp/.tmp
}

# Useful host data
ii () {
  echo -e "\nYou are logged on ${RED}$HOST"
  echo -e "\nAdditionnal information:$NC " ; uname -a
  echo -e "\n${RED}Users logged on:$NC " ; w -h
  echo -e "\n${RED}Current date :$NC " ; date
  echo -e "\n${RED}Machine stats :$NC " ; uptime
  echo -e "\n${RED}Current network location :$NC " ; scselect
  echo -e "\n${RED}Public facing IP Address :$NC " ;myip
  #echo -e "\n${RED}DNS Configuration:$NC " ; scutil --dns
  echo
}

# Advanced tree one liners
l () {
  tree -L 1 -CDFha --du --dirsfirst $@;
};

ll () {
  l -L 2 $@;
};

function lll() {
  l -L 3 $@;
};

# Get all processes owned by user
users_procs() {
  ps $@ -u $1 -o pid,%cpu,%mem,start,time,bsdtime,command ;
};

# Send RM to Trashcan instead
trash () {
  command mv "$@" ~/.Trash ;
};

# Extract:  Extract most know archives with one command
extract () {
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xjf $1     ;;
      *.tar.gz)    tar xzf $1     ;;
      *.bz2)       bunzip2 $1     ;;
      *.rar)       unrar e $1     ;;
      *.gz)        gunzip $1      ;;
      *.tar)       tar xf $1      ;;
      *.tbz2)      tar xjf $1     ;;
      *.tgz)       tar xzf $1     ;;
      *.zip)       unzip $1       ;;
      *.Z)         uncompress $1  ;;
      *.7z)        7z x $1        ;;
      *)     echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
};

# Quickly GREP a process
psa () {
  ps aux | grep $1
};

# Git branch details
function parse_git_dirty() {
  [[ $(git status 2> /dev/null | tail -n1) != *"working directory clean"* ]] && echo "*"
};

function parse_git_branch() {
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$(parse_git_dirty)/"
};
